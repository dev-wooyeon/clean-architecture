## 15장. 아키텍처란?

(여담) 읽으면서 어려움을 느끼는 부분이 ‘컴포넌트’에 대한 정의같다. 그 규모가 내가 실질적으로 코딩하는 부분에 잘 대입이 안된다. → 내가 코딩하고 있는 스케일은, 이 장 끝에서 말하는 통짜 컴포넌트여서 그런것같다.

- 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 분리해야한다.
- 세부 사항에 대해 독립성을 유지하는 것이 훌륭한 아키텍처이다.
- 예를들어, 내게 가장 와닿는 세부사항 중 하나인 실제 DB종류에 대해 어떤것을 선택하건 문제가 되지 않고, 때문에 그 선택에 대한 결정을 최대한 미룰 수 있도록 하는것! 을 의미한다.
- 이 장에서 인상적이었던 부분은, “소프트웨어 아키텍처의 목표가 시스템을 제대로 동작하도록 만드는데 있다.”가 첫번째 목표가 아니라는 점이다.

<br>

## 16장. 독립성

- 좋은 아키텍처는 다음을 지원해야 한다.
    - 시스템의 유스케이스
    - 시스템의 운영
    - 시스템의 개발
    - 시스템의 배포
- 유스케이스
    - 유스케이스(시스템의 행위)에 대해 영향력을 행사하기 위해서라기보다는, 아키텍처를 살핌으로써 해당 유스케이스의 의도를 명확히 확인할 수 있게 하기 위함이다.
- 운영
    - 같은 주소에서의 멀티 스레드, 독립된 주소 공간에서 실행되는 소수의 프로세스, 혹은 단일 프로세스에서 실행되는 단순 모노리틱 프로그램. 어떤 구조를 가질지 결정하는 것에 대해 열어두어야 한다.
    - 각 컴포넌트를 적절히 격리해놓는다면 추후에 어떤 구조를 가지게 될지라도 충분히 적용 가능하지만, 모노리틱 구조라면 분리를 요하는 다른 구조들로의 전환이 어려울 것이다.
- 개발
    - 아키텍처가 핵심적인 역할을 수행하는 부분이 바로 개발 환경 지원이다.
    - 콘웨이의 법칙
        - 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.
    - 독립적인 각각의 개발팀이 서로를 방해하지 않도록 아키텍처를 만들어야 한다.
- 배포
    - 목표는 '즉각적인 배포'다.
    - 위에 '개발 지원'에서와 마찬가지로 아키텍처는, 독립된 각각의 팀이 본인들의 변경사항이 적용된 컴포넌트를 즉각적으로 배포할 수 있도록 지원해야 한다.
- 저자는 이 책이 끝날 때까지 아래 두 사항에 대해 계속 얘기할 것 같다.
    - 선택사항을 열어놔라 - 현실적으로 위 사항들에 대해 균형적인 지원을 하기란 쉽지 않다. 요구사항도 계속 해서 변한다. 그러니 선택사항을 가능한한 많이, 오래 열어두어라. 변경을 쉽게 받아들일 수 있게하라.
    - 서로 다른 이유로 변경되는 것들은 분리시켜놔라. - 특히 ‘업무규칙’과 ‘세부사항’을 분리시켜라.
- 결합 분리 모드
    - ‘계층(ex. UI, 업무로직, 데이터베이스..)’을 수평적으로 분할하고 그걸 수직으로 가로지르는 ‘유스케이스’로 시스템을 분할한다.
    - (첨부된 그림을 보면 ‘주문 추가용 데이터베이스’와 ‘주문 삭제용 데이터베이스’가 분리돼있는데 그게 말이 되나?? 데이터베이스는 하난데? 리포지토리 분리라고 생각하려해도 저건 ‘주문’이라는 하나의 테이블에서 발생하는 일 아닌가..? 난 잘 모르겠다..)
    - 이전에 아는분이 회사에서 msa(micro service architecture)를 진행하고 있다고 해서 ‘그런것도 있군요,,’ 했었는데 이제 뭔지 알겠다. 분리하는 컴포넌트 수준이 ‘서비스’ 수준인것을 지칭하나보다.
- 이전에 내가 의문을 가졌던 중복에 대한 이야기가 나왔다. 이전에 ‘다른 목적을 갖는 코드들은 클래스를 명확하게 분리해라’ 라고 해서 ‘같은 역할을 수행하지만 목적이 다를 수 있다면 클래스를 분리해서 똑같은 코드를 중복해서 쓰라는 말이야? 중복을 최소화하라며!’ 라고 의문을 품었었는데 여기서 중복을 두가지 형태로 나누었다.
    - 진짜 중복
        - 리얼 중복이다. A에서 발생시킨 변경을 B에 똑같이 적용시켜야할 경우에 A와 B는 진짜 중복이다.
    - 우발적 중복
        - 중복이라고 착각하는 중복이다. 현재는 형태가 같을지라도, 추구하는 목표가 다르기때문에 추후에 다른 방향으로 발전할 것이고 나중에는 완전히 다른 형태를 갖게될 수도 있다.
    - 내가 개발하고 있는 서비스에서 ‘진짜 중복’을 분리해낸 경험이 있었다. 그 후 실상 ‘우발적 중복’이었던 것을 ‘진짜 중복’으로 착각해 분리해냄으로써 추후에 곤란해졌던 기억이 있다. 이제 두 차이를 명확히 알것같다.

<br>

## 17장. 경계: 선 긋기

- 이전에 현우님이 ‘프레임워크조차 선택사항으로 남겨둬야할까요’ 라고 의문을 던져주셨는데, 저자는 본인이 그렇게 함으로써 FitNess를 성공적으로 만들어냈다고 한다. 하지만 난 우리가 논의할 때 주장했던것처럼 그렇게까지해야할까? 싶었다. 물론 내가 아직 응애 개발자여서 그렇게 생각하는 것일 수 있겠으나, 프레임워크라는게 개발 편의성을 위해 사용하는 것 아닌가..?라는 생각이다..
- 선은 어디에?  관계 있는 것과 없는 것들 사이에.
- 그리고 의존성 화살표는 ‘저수준 세부사항 → 고수준 업무규칙’ 의 방향으로. ⇒ 이게 바로 플러그인 형태의 연결

<br>

## 18장. 경계 해부학

- 소스 수준 분리 모드: 물리적으로 엄격히 분리되어 있지 않은 형태로, 같은 주소 공간을 공유하며 그저 나름의 규칙에 따라 분리되어 있는 단일체(monolith). 하나의 실행 파일.
- 경계 횡단: 저수준 클라이언트 → 고수준 서비스 로 향하는 함수 호출
    - 런타임 의존성과 컴파일타임 의존성은 모두 같은 방향으로 향한다.
        - 런타임 의존성이 제어흐름 을 의미하는 것 같다.
    - 저수준 클라이언트와 서비스 구현체 사이에 서비스 인터페이스를 두고, 클라이언트과 서비스 구현체 둘 다 인터페이스를 바라보게함으로써 컴파일타임 의존성을 역전시킨다.
- 다양한 예시들이 나오는데 결국 저자가 하고픈 말은 똑같다. 저수준 & 고수준 명확히 분리해서 고수준에 저수준에 대한 내용 안들어가게하고, 그 사이에 추상체 둬서 의존성 역전시켜라.

<br>

## 19장. 정책과 수준

- 자꾸 수준 얘기해서 이해 안가던 것이 여기서 정리가 됐다.
- 수준: 입력과 출력까지의 거리 ⇒ 시스템의 입/출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다. 입/출력을 다루는 정책은 최하위 수준인것.
- 또 똑같은 얘기한다. ‘저수준 컴포넌트는 고수준 컴포넌트에 플러그인되어야 한다.’

<br>

